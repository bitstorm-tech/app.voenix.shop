package com.jotoai.voenix.shop.order.internal.service

import com.jotoai.voenix.shop.cart.api.CartFacade
import com.jotoai.voenix.shop.cart.api.CartQueryService
import com.jotoai.voenix.shop.cart.api.dto.CartOrderInfo
import com.jotoai.voenix.shop.common.exception.BadRequestException
import com.jotoai.voenix.shop.order.api.OrderFacade
import com.jotoai.voenix.shop.order.api.dto.CreateOrderRequest
import com.jotoai.voenix.shop.order.api.dto.OrderDto
import com.jotoai.voenix.shop.order.api.enums.OrderStatus
import com.jotoai.voenix.shop.order.api.exception.OrderAlreadyExistsException
import com.jotoai.voenix.shop.order.api.exception.OrderCannotBeCancelledException
import com.jotoai.voenix.shop.order.api.exception.OrderNotFoundException
import com.jotoai.voenix.shop.order.internal.entity.Order
import com.jotoai.voenix.shop.order.internal.entity.OrderItem
import com.jotoai.voenix.shop.order.internal.repository.OrderRepository
import com.jotoai.voenix.shop.user.api.UserQueryService
import jakarta.persistence.EntityManager
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class OrderFacadeImpl(
    private val orderRepository: OrderRepository,
    private val cartQueryService: CartQueryService,
    private val cartFacade: CartFacade,
    private val userQueryService: UserQueryService,
    private val orderAssembler: OrderAssembler,
    private val entityManager: EntityManager,
) : OrderFacade {
    private val logger = LoggerFactory.getLogger(OrderFacadeImpl::class.java)

    /**
     * Creates an order from the user's active cart
     */
    @Transactional
    override fun createOrderFromCart(
        userId: Long,
        request: CreateOrderRequest,
    ): OrderDto {
        // Validate user exists
        userQueryService.getUserById(userId)

        // Get cart information for order
        val cartInfo =
            cartQueryService.getActiveCartForOrder(userId)
                ?: throw BadRequestException("No active cart found for user: $userId")

        // Validate cart is not empty
        if (cartInfo.isEmpty) {
            throw BadRequestException("Cannot create order from empty cart")
        }

        // Check if order already exists for this cart
        if (orderRepository.existsByCartId(cartInfo.id)) {
            throw OrderAlreadyExistsException(cartInfo.id)
        }

        // Refresh cart prices to ensure accuracy
        val refreshedCart = cartFacade.refreshCartPricesForOrder(cartInfo.id)

        // Calculate totals
        val subtotal = refreshedCart.totalPrice
        val taxAmount = calculateTax(subtotal)
        val shippingAmount = calculateShipping(refreshedCart)
        val totalAmount = subtotal + taxAmount + shippingAmount

        // Determine billing address
        val billingAddress =
            if (request.useShippingAsBilling || request.billingAddress == null) {
                request.shippingAddress.toEntity()
            } else {
                request.billingAddress.toEntity()
            }

        // Create order (orderNumber will be generated by database)
        val order =
            Order(
                userId = userId,
                customerEmail = request.customerEmail,
                customerFirstName = request.customerFirstName,
                customerLastName = request.customerLastName,
                customerPhone = request.customerPhone,
                shippingAddress = request.shippingAddress.toEntity(),
                billingAddress = billingAddress,
                subtotal = subtotal,
                taxAmount = taxAmount,
                shippingAmount = shippingAmount,
                totalAmount = totalAmount,
                status = OrderStatus.PENDING,
                cartId = refreshedCart.id,
                notes = request.notes,
            )

        // Convert cart items to order items
        refreshedCart.items.forEach { cartItem ->
            val orderItem =
                OrderItem(
                    order = order,
                    articleId = cartItem.articleId,
                    variantId = cartItem.variantId ?: 0L,
                    quantity = cartItem.quantity,
                    pricePerItem = cartItem.priceAtTime,
                    totalPrice = cartItem.totalPrice,
                    generatedImageId = cartItem.generatedImageId,
                    generatedImageFilename = null, // TODO: Get from image service if needed
                    promptId = cartItem.promptId,
                    customData = cartItem.customData ?: emptyMap(),
                )
            order.addItem(orderItem)
        }

        // Save order
        val savedOrder = orderRepository.save(order)

        // Flush to database to trigger the default value generation
        entityManager.flush()

        // Refresh the entity to get the generated order number
        entityManager.refresh(savedOrder)

        // Mark cart as converted
        cartQueryService.markCartAsConverted(refreshedCart.id)

        logger.info(
            "Created order {} for user {} from cart {} with total amount {}",
            savedOrder.orderNumber,
            userId,
            refreshedCart.id,
            totalAmount,
        )

        return orderAssembler.toDto(savedOrder)
    }

    /**
     * Cancels an order (if allowed)
     */
    @Transactional
    override fun cancelOrder(
        userId: Long,
        orderId: UUID,
    ): OrderDto {
        val order =
            orderRepository
                .findByIdAndUserId(orderId, userId)
                .orElseThrow { OrderNotFoundException("Order", "id", orderId) }

        if (!order.canBeCancelled()) {
            throw OrderCannotBeCancelledException(orderId.toString(), order.status)
        }

        order.status = OrderStatus.CANCELLED
        val savedOrder = orderRepository.save(order)

        logger.info("Cancelled order {} for user {}", orderId, userId)

        return orderAssembler.toDto(savedOrder)
    }

    /**
     * Calculates tax amount (8% for now, configurable later)
     */
    private fun calculateTax(subtotal: Long): Long = (subtotal * TAX_RATE).toLong()

    /**
     * Calculates shipping amount ($4.99 flat rate for now)
     */
    private fun calculateShipping(cart: CartOrderInfo): Long {
        // Simple flat rate shipping for now
        return if (cart.isEmpty) 0L else SHIPPING_RATE_CENTS
    }

    companion object {
        private const val TAX_RATE = 0.08 // 8%
        private const val SHIPPING_RATE_CENTS = 499L // $4.99
    }
}
