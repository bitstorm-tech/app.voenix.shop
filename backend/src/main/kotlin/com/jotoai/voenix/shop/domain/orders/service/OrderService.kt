package com.jotoai.voenix.shop.domain.orders.service

import com.jotoai.voenix.shop.common.dto.PaginatedResponse
import com.jotoai.voenix.shop.common.exception.BadRequestException
import com.jotoai.voenix.shop.common.exception.ResourceNotFoundException
import com.jotoai.voenix.shop.domain.cart.entity.Cart
import com.jotoai.voenix.shop.domain.cart.enums.CartStatus
import com.jotoai.voenix.shop.domain.cart.repository.CartRepository
import com.jotoai.voenix.shop.domain.orders.assembler.OrderAssembler
import com.jotoai.voenix.shop.domain.orders.dto.CreateOrderRequest
import com.jotoai.voenix.shop.domain.orders.dto.OrderDto
import com.jotoai.voenix.shop.domain.orders.entity.Order
import com.jotoai.voenix.shop.domain.orders.entity.OrderItem
import com.jotoai.voenix.shop.domain.orders.enums.OrderStatus
import com.jotoai.voenix.shop.domain.orders.repository.OrderRepository
import com.jotoai.voenix.shop.user.api.UserQueryService
import jakarta.persistence.EntityManager
import org.slf4j.LoggerFactory
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class OrderService(
    private val orderRepository: OrderRepository,
    private val cartRepository: CartRepository,
    private val userQueryService: UserQueryService,
    private val orderAssembler: OrderAssembler,
    private val entityManager: EntityManager,
) {
    private val logger = LoggerFactory.getLogger(OrderService::class.java)

    /**
     * Creates an order from the user's active cart
     */
    @Transactional
    fun createOrderFromCart(
        userId: Long,
        request: CreateOrderRequest,
    ): OrderDto {
        // Validate user exists
        userQueryService.getUserById(userId)
        val cart = findActiveCartByUserId(userId)

        // Validate cart is not empty
        if (cart.isEmpty()) {
            throw BadRequestException("Cannot create order from empty cart")
        }

        // Check if order already exists for this cart
        if (orderRepository.existsByCartId(cart.id!!)) {
            throw BadRequestException("Order already exists for this cart")
        }

        // Refresh cart prices to ensure accuracy
        refreshCartPrices(cart)

        // Calculate totals
        val subtotal = cart.getTotalPrice()
        val taxAmount = calculateTax(subtotal)
        val shippingAmount = calculateShipping(cart)
        val totalAmount = subtotal + taxAmount + shippingAmount

        // Determine billing address
        val billingAddress =
            if (request.useShippingAsBilling || request.billingAddress == null) {
                request.shippingAddress.toEntity()
            } else {
                request.billingAddress.toEntity()
            }

        // Create order (orderNumber will be generated by database)
        val order =
            Order(
                userId = userId,
                customerEmail = request.customerEmail,
                customerFirstName = request.customerFirstName,
                customerLastName = request.customerLastName,
                customerPhone = request.customerPhone,
                shippingAddress = request.shippingAddress.toEntity(),
                billingAddress = billingAddress,
                subtotal = subtotal,
                taxAmount = taxAmount,
                shippingAmount = shippingAmount,
                totalAmount = totalAmount,
                status = OrderStatus.PENDING,
                cart = cart,
                notes = request.notes,
            )

        // Convert cart items to order items
        cart.items.forEach { cartItem ->
            val orderItem =
                OrderItem(
                    order = order,
                    article = cartItem.article,
                    variant = cartItem.variant,
                    quantity = cartItem.quantity,
                    pricePerItem = cartItem.priceAtTime,
                    totalPrice = cartItem.getTotalPrice(),
                    generatedImageId = cartItem.generatedImage?.id,
                    generatedImageFilename = cartItem.generatedImage?.filename,
                    prompt = cartItem.prompt,
                    customData = cartItem.customData,
                )
            order.addItem(orderItem)
        }

        // Save order
        val savedOrder = orderRepository.save(order)

        // Flush to database to trigger the default value generation
        entityManager.flush()

        // Refresh the entity to get the generated order number
        entityManager.refresh(savedOrder)

        // Mark cart as converted
        cart.status = CartStatus.CONVERTED
        cartRepository.save(cart)

        logger.info(
            "Created order {} for user {} from cart {} with total amount {}",
            savedOrder.orderNumber,
            userId,
            cart.id,
            totalAmount,
        )

        return orderAssembler.toDto(savedOrder)
    }

    /**
     * Gets an order by ID, ensuring it belongs to the user
     */
    @Transactional(readOnly = true)
    fun getOrder(
        userId: Long,
        orderId: UUID,
    ): OrderDto {
        val order = getOrderEntity(userId, orderId)
        return orderAssembler.toDto(order)
    }

    /**
     * Gets an order entity by ID, ensuring it belongs to the user
     */
    @Transactional(readOnly = true)
    fun getOrderEntity(
        userId: Long,
        orderId: UUID,
    ): Order =
        orderRepository
            .findByIdAndUserId(orderId, userId)
            .orElseThrow { ResourceNotFoundException("Order not found: $orderId") }

    /**
     * Gets all orders for a user
     */
    @Transactional(readOnly = true)
    fun getUserOrders(
        userId: Long,
        pageable: Pageable,
    ): PaginatedResponse<OrderDto> {
        val ordersPage = orderRepository.findByUserId(userId, pageable)
        return PaginatedResponse(
            content = ordersPage.content.map { orderAssembler.toDto(it) },
            currentPage = ordersPage.number,
            totalPages = ordersPage.totalPages,
            totalElements = ordersPage.totalElements,
            size = ordersPage.size,
        )
    }

    /**
     * Gets orders for a user with specific status
     */
    @Transactional(readOnly = true)
    fun getUserOrdersByStatus(
        userId: Long,
        status: OrderStatus,
        pageable: Pageable,
    ): PaginatedResponse<OrderDto> {
        val ordersPage = orderRepository.findByUserIdAndStatus(userId, status, pageable)
        return PaginatedResponse(
            content = ordersPage.content.map { orderAssembler.toDto(it) },
            currentPage = ordersPage.number,
            totalPages = ordersPage.totalPages,
            totalElements = ordersPage.totalElements,
            size = ordersPage.size,
        )
    }

    /**
     * Updates an order status
     */
    @Transactional
    fun updateOrderStatus(
        orderId: UUID,
        status: OrderStatus,
    ): OrderDto {
        val order =
            orderRepository
                .findById(orderId)
                .orElseThrow { ResourceNotFoundException("Order not found: $orderId") }

        order.status = status
        val savedOrder = orderRepository.save(order)

        logger.info("Updated order {} status to {}", orderId, status)

        return orderAssembler.toDto(savedOrder)
    }

    /**
     * Cancels an order (if allowed)
     */
    @Transactional
    fun cancelOrder(
        userId: Long,
        orderId: UUID,
    ): OrderDto {
        val order =
            orderRepository
                .findByIdAndUserId(orderId, userId)
                .orElseThrow { ResourceNotFoundException("Order not found: $orderId") }

        if (!order.canBeCancelled()) {
            throw BadRequestException("Order cannot be cancelled in current status: ${order.status}")
        }

        order.status = OrderStatus.CANCELLED
        val savedOrder = orderRepository.save(order)

        logger.info("Cancelled order {} for user {}", orderId, userId)

        return orderAssembler.toDto(savedOrder)
    }

    /**
     * Calculates tax amount (8% for now, configurable later)
     */
    private fun calculateTax(subtotal: Long): Long = (subtotal * TAX_RATE).toLong()

    /**
     * Calculates shipping amount ($4.99 flat rate for now)
     */
    private fun calculateShipping(cart: Cart): Long {
        // Simple flat rate shipping for now
        return if (cart.isEmpty()) 0L else SHIPPING_RATE_CENTS
    }

    /**
     * Refreshes cart prices to current prices
     */
    private fun refreshCartPrices(cart: Cart) {
        cart.items.forEach { item ->
            val currentPrice = getCurrentPrice(item.article)
            if (item.priceAtTime != currentPrice) {
                logger.warn(
                    "Price changed for cart item {}: {} -> {}",
                    item.id,
                    item.priceAtTime,
                    currentPrice,
                )
                item.priceAtTime = currentPrice
            }
        }
    }

    /**
     * Gets current price from article cost calculation
     */
    private fun getCurrentPrice(article: com.jotoai.voenix.shop.domain.articles.entity.Article): Long =
        article.costCalculation?.salesTotalGross?.toLong() ?: 0L

    private fun findActiveCartByUserId(userId: Long): Cart =
        cartRepository
            .findActiveCartByUserId(userId)
            .orElseThrow { BadRequestException("No active cart found for user: $userId") }

    companion object {
        private const val TAX_RATE = 0.08 // 8%
        private const val SHIPPING_RATE_CENTS = 499L // $4.99
    }
}
